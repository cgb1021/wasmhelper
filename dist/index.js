function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}!function(t,n){"object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).wasmhelper={})}(this,function(t){"use strict";var s=function(t,n){return n?(void 0===n.env&&(n.env={}),["emscripten_resize_heap","emscripten_memcpy_big","emscripten_notify_memory_growth","emscripten_asm_const_int"].forEach(function(t){"function"!=typeof n.env[t]&&(n.env[t]=function(){})}),void 0===n.wasi_snapshot_preview1&&(n.wasi_snapshot_preview1={}),["proc_exit"].forEach(function(t){"function"!=typeof n.wasi_snapshot_preview1[t]&&(n.wasi_snapshot_preview1[t]=function(){})}),WebAssembly.instantiateStreaming(fetch(t),n)):WebAssembly.compileStreaming(fetch(t))},f="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,n=console.warn.bind(console);function p(t){p.shown||(p.shown={}),p.shown[t]||(p.shown[t]=1,n(t))}var l={lengthBytesUTF8:function(t){for(var n=0,e=0;e<t.length;++e){var r=t.charCodeAt(e);(r=55296<=r&&r<=57343?65536+((1023&r)<<10)|1023&t.charCodeAt(++e):r)<=127?++n:n+=r<=2047?2:r<=65535?3:4}return n},stringToUTF8:function(t,n,e,r){if(!(0<r))return 0;for(var o=n instanceof ArrayBuffer?new Uint8Array(n):n,n=e,i=e+r,s=0;s<t.length;++s){var a=t.charCodeAt(s);if((a=55296<=a&&a<=57343?65536+((1023&a)<<10)|1023&t.charCodeAt(++s):a)<=127){if(i<=e)break;o[e++]=a}else if(a<=2047){if(i<=e+1)break;o[e++]=192|a>>6,o[e++]=128|63&a}else if(a<=65535){if(i<=e+2)break;o[e++]=224|a>>12,o[e++]=128|a>>6&63,o[e++]=128|63&a}else{if(i<=e+3)break;2097152<=a&&p("Invalid Unicode code point 0x"+a.toString(16)+" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x1FFFFF)."),o[e++]=240|a>>18,o[e++]=128|a>>12&63,o[e++]=128|a>>6&63,o[e++]=128|63&a}}return o[e]=0,e-n},UTF8ToString:function(t,n,e){for(var r=t instanceof ArrayBuffer?new Uint8Array(t):t,o=n+e,i=n;r[i]&&!(o<=i);)++i;if(16<i-n&&r.subarray&&f)return f.decode(r.subarray(n,i));for(var s="";n<i;){var a,u,c=r[n++];128&c?(a=63&r[n++],192!=(224&c)?(u=63&r[n++],(c=224==(240&c)?(15&c)<<12|a<<6|u:(240!=(248&c)&&p("Invalid UTF-8 leading byte 0x"+c.toString(16)+" encountered when deserializing a UTF-8 string in wasm memory to a JS string!"),(7&c)<<18|a<<12|u<<6|63&r[n++]))<65536?s+=String.fromCharCode(c):(u=c-65536,s+=String.fromCharCode(55296|u>>10,56320|1023&u))):s+=String.fromCharCode((31&c)<<6|a)):s+=String.fromCharCode(c)}return s}};function e(n,e){var r=this;this.HEAP8=null,this.HEAP16=null,this.HEAP32=null,this.HEAPU8=null,this.HEAPU16=null,this.HEAPU32=null,this.HEAPF32=null,this.HEAPF64=null,this.exports=null,this.memory=null,this.stack=0;function o(t){if("object"===_typeof(t.memory))r.memory=t.memory;else{if("object"!==_typeof(e.env.memory))throw new Error("no memory buffer");r.memory=e.env.memory}var n=r.memory.buffer;r.HEAP8=new Int8Array(n),r.HEAP16=new Int16Array(n),r.HEAP32=new Int32Array(n),r.HEAPU8=new Uint8Array(n),r.HEAPU16=new Uint16Array(n),r.HEAPU32=new Uint32Array(n),r.HEAPF32=new Float32Array(n),r.HEAPF64=new Float64Array(n),r.exports=t}var i;"string"==typeof n?(i="function"==typeof e.ready?e.ready:null,delete e.ready,s(n,e).then(function(t){o(t.instance.exports),i&&(i.call(r,n),i=null)})):o(n.exports)}e.prototype.ccall=function(t,n,e){var r=this.exports,o=this,i={string:function(t){var n,e=0;return null!=t&&0!==t&&(n=1+(t.length<<2),e=r.stackAlloc(n),l.stringToUTF8(t,o.HEAPU8,e,n)),e},array:function(t){var n=o.HEAP32.BYTES_PER_ELEMENT,e=r.stackAlloc(t.length*n);return o.HEAP32.set(t,e/n),e}};var s=[],a=0;if(e)for(var u=0;u<e.length;u++){var c=i[Array.isArray(e[u])?"array":_typeof(e[u])];c?(0===a&&(a=r.stackSave()),s[u]=c(e[u])):s[u]=e[u]}var f,t=r[t].apply(null,s);return f=t,t="string"===n?l.UTF8ToString(o.HEAPU8,f):"boolean"===n?Boolean(f):f,0!==a&&r.stackRestore(a),t},e.prototype.mem2str=function(t,n){return l.UTF8ToString(this.HEAPU8,t,n)},e.prototype.str2mem=function(t){var n=l.lengthBytesUTF8(t),e=this.malloc(n+1);return l.stringToUTF8(t,this.HEAPU8,e,n),e},e.prototype.arr2mem=function(t){var n=this.heap(1<arguments.length&&void 0!==arguments[1]?arguments[1]:"i32"),e=n.BYTES_PER_ELEMENT,r=this.malloc(t.length*e);return n.set(t,r/e),r},e.prototype.mem2arr=function(t,n){var e=this.heap(2<arguments.length&&void 0!==arguments[2]?arguments[2]:"i32"),t=t/e.BYTES_PER_ELEMENT;return Array.from(e.subarray(t,t+n))},e.prototype.malloc=function(t){var n=this.exports,e=0;if("function"==typeof n.malloc)e=n.malloc(t);else{var r=n.stackSave();if(r<t)throw new Error("stack overflow");0===this.stack&&(this.stack=r),e=n.stackAlloc(t)}return e},e.prototype.free=function(){var n=this.exports;if("function"==typeof n.free){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];e.forEach(function(t){n.free(t)})}this.stack&&(n.stackRestore(this.stack),this.stack=0)},e.prototype.heap=function(){switch(0<arguments.length&&void 0!==arguments[0]?arguments[0]:"i32"){case"i8":return this.HEAP8;case"i16":return this.HEAP16;case"u8":return this.HEAPU8;case"u16":return this.HEAPU16;case"u32":return this.HEAPU32;case"float":return this.HEAPF32;case"double":return this.HEAPF64;default:return this.HEAP32}},e.prototype.grow=function(t){return this.memory.grow(t)};var o="webassemblyinit",i="\nconst UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\nconst err = console.warn.bind(console)\nfunction warnOnce(text) {\n\tif (!warnOnce.shown) warnOnce.shown = {}\n\tif (!warnOnce.shown[text]) {\n\t\twarnOnce.shown[text] = 1\n\t\terr(text)\n\t}\n}\nfunction lengthBytesUTF8(str) {\n\tvar len = 0\n\tfor (var i = 0; i < str.length; ++i) {\n\t\tvar u = str.charCodeAt(i)\n\t\tif (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023\n\t\tif (u <= 127) ++len\n\t\telse if (u <= 2047) len += 2\n\t\telse if (u <= 65535) len += 3\n\t\telse len += 4\n\t}\n\treturn len\n}\n/*\n * @description: c字符数组转js字符串\n * @param {TpyeArray|ArrayBuffer} buffOrArr: \n * @param {Number} idx: 开始地址\n * @param {Number} maxBytesToRead: 读取数量（可选）\n */\nfunction UTF8ToString(buffOrArr, idx, maxBytesToRead) {\n\tconst heap = buffOrArr instanceof ArrayBuffer ? new Uint8Array(buffOrArr) : buffOrArr\n\tvar endIdx = idx + maxBytesToRead\n\tvar endPtr = idx\n\twhile (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr\n\tif (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n\t\treturn UTF8Decoder.decode(heap.subarray(idx, endPtr))\n\t} else {\n\t\tvar str = ''\n\t\twhile (idx < endPtr) {\n\t\t\tvar u0 = heap[idx++]\n\t\t\tif (!(u0 & 128)) {\n\t\t\t\tstr += String.fromCharCode(u0)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar u1 = heap[idx++] & 63\n\t\t\tif ((u0 & 224) == 192) {\n\t\t\t\tstr += String.fromCharCode((u0 & 31) << 6 | u1)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar u2 = heap[idx++] & 63\n\t\t\tif ((u0 & 240) == 224) {\n\t\t\t\tu0 = (u0 & 15) << 12 | u1 << 6 | u2\n\t\t\t} else {\n\t\t\t\tif ((u0 & 248) != 240) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!')\n\t\t\t\tu0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63\n\t\t\t}\n\t\t\tif (u0 < 65536) {\n\t\t\t\tstr += String.fromCharCode(u0)\n\t\t\t} else {\n\t\t\t\tvar ch = u0 - 65536\n\t\t\t\tstr += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)\n\t\t\t}\n\t\t}\n\t}\n\treturn str\n}\n/*\n * @description: c字符数组转js字符串\n * @param {String} buffOrArr: \n * @param {TpyeArray|ArrayBuffer} heap: \n * @param {Number} outIdx: 开始地址\n * @param {Number} maxBytesToWrite: \n */\nfunction stringToUTF8(str, buffOrArr, outIdx, maxBytesToWrite) {\n\tif (!(maxBytesToWrite > 0)) return 0\n\tconst heap = buffOrArr instanceof ArrayBuffer ? new Uint8Array(buffOrArr) : buffOrArr\n\tvar startIdx = outIdx\n\tvar endIdx = outIdx + maxBytesToWrite\n\tfor (var i = 0; i < str.length; ++i) {\n\t\tvar u = str.charCodeAt(i)\n\t\tif (u >= 55296 && u <= 57343) {\n\t\t\tvar u1 = str.charCodeAt(++i)\n\t\t\tu = 65536 + ((u & 1023) << 10) | u1 & 1023\n\t\t}\n\t\tif (u <= 127) {\n\t\t\tif (outIdx >= endIdx) break\n\t\t\theap[outIdx++] = u\n\t\t} else if (u <= 2047) {\n\t\t\tif (outIdx + 1 >= endIdx) break\n\t\t\theap[outIdx++] = 192 | u >> 6\n\t\t\theap[outIdx++] = 128 | u & 63\n\t\t} else if (u <= 65535) {\n\t\t\tif (outIdx + 2 >= endIdx) break\n\t\t\theap[outIdx++] = 224 | u >> 12\n\t\t\theap[outIdx++] = 128 | u >> 6 & 63\n\t\t\theap[outIdx++] = 128 | u & 63\n\t\t} else {\n\t\t\tif (outIdx + 3 >= endIdx) break\n\t\t\tif (u >= 2097152) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x1FFFFF).')\n\t\t\theap[outIdx++] = 240 | u >> 18\n\t\t\theap[outIdx++] = 128 | u >> 12 & 63\n\t\t\theap[outIdx++] = 128 | u >> 6 & 63\n\t\t\theap[outIdx++] = 128 | u & 63\n\t\t}\n\t}\n\theap[outIdx] = 0\n\treturn outIdx - startIdx\n}\n\nvar utils = {\n  lengthBytesUTF8,\n\tstringToUTF8,\n\tUTF8ToString\n}\n\nfunction WASM(instance, importObject) {\n\tthis.HEAP8 = null\n\tthis.HEAP16 = null\n\tthis.HEAP32 = null\n\tthis.HEAPU8 = null\n\tthis.HEAPU16 = null\n\tthis.HEAPU32 = null\n\tthis.HEAPF32 = null\n\tthis.HEAPF64 = null\n\tthis.exports = null\n\tthis.memory = null\n\tthis.stack = 0\n\tconst init = (exports) => {\n\t\tif (typeof exports.memory === 'object') {\n\t\t\tthis.memory = exports.memory\n\t\t} else if (typeof importObject.env.memory === 'object') {\n\t\t\tthis.memory = importObject.env.memory\n\t\t} else {\n\t\t\tthrow new Error('no memory buffer')\n\t\t}\n\t\tconst buf = this.memory.buffer\n\t\tthis.HEAP8 = new Int8Array(buf)\n\t\tthis.HEAP16 = new Int16Array(buf)\n\t\tthis.HEAP32 = new Int32Array(buf)\n\t\tthis.HEAPU8 = new Uint8Array(buf)\n\t\tthis.HEAPU16 = new Uint16Array(buf)\n\t\tthis.HEAPU32 = new Uint32Array(buf)\n\t\tthis.HEAPF32 = new Float32Array(buf)\n\t\tthis.HEAPF64 = new Float64Array(buf)\n\t\tthis.exports = exports\n\t}\n\tif (typeof instance === 'string') {\n\t\tlet callback = typeof importObject.ready === 'function' ? importObject.ready : null\n\t\tdelete importObject.ready\n\t\tload(instance, importObject).then((res) => {\n\t\t\tinit(res.instance.exports)\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(this, instance)\n\t\t\t\tcallback = null\n\t\t\t}\n\t\t})\n\t} else {\n\t\tinit(instance.exports)\n\t}\n}\n/*\n * @description: 调用c函数\n * @param {String} ident: c函数名称\n * @param {String} returnType: 返回值类型{string|number|boolean|null}\n * @param {Array} args: 参数数组\n * @return {Any}\n */\nWASM.prototype.ccall = function (ident, returnType, args) {\n\tconst exports = this.exports\n\tconst self = this\n\tvar toC = {\n\t\t'string': function (str) {\n\t\t\tvar ret = 0\n\t\t\tif (str !== null && str !== undefined && str !== 0) {\n\t\t\t\tvar len = (str.length << 2) + 1\n\t\t\t\tret = exports.stackAlloc(len)\n\t\t\t\tutils.stringToUTF8(str, self.HEAPU8, ret, len)\n\t\t\t}\n\t\t\treturn ret\n\t\t},\n\t\t'array': function (arr) {\n\t\t\tconst bytes = self.HEAP32.BYTES_PER_ELEMENT\n\t\t\tvar ret = exports.stackAlloc(arr.length * bytes)\n\t\t\tself.HEAP32.set(arr, ret / bytes)\n\t\t\treturn ret\n\t\t}\n\t}\n\n\tfunction convertReturnValue(ret) {\n\t\tif (returnType === 'string') return utils.UTF8ToString(self.HEAPU8, ret)\n\t\tif (returnType === 'boolean') return Boolean(ret)\n\t\treturn ret\n\t}\n\tvar cArgs = []\n\tvar stack = 0\n\tif (args) {\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tconst type = Array.isArray(args[i]) ? 'array' : typeof args[i]\n\t\t\tvar converter = toC[type]\n\t\t\tif (converter) {\n\t\t\t\tif (stack === 0) stack = exports.stackSave()\n\t\t\t\tcArgs[i] = converter(args[i])\n\t\t\t} else {\n\t\t\t\tcArgs[i] = args[i]\n\t\t\t}\n\t\t}\n\t}\n\tvar ret = exports[ident].apply(null, cArgs)\n\tret = convertReturnValue(ret)\n\tif (stack !== 0) exports.stackRestore(stack)\n\treturn ret\n}\n/*\n * @description: 从内存获取字符串\n * @param {Number} ptr: buffer offset\n * @param {Number} size: 字符串长度（可选）\n * @return {String}\n */\nWASM.prototype.mem2str = function (ptr, size) {\n\treturn utils.UTF8ToString(this.HEAPU8, ptr, size)\n}\n/*\n * @description: 把字符串放入内存\n * @param {String} str: 字符串\n * @return {Number} buffer offset\n */\nWASM.prototype.str2mem = function (str) {\n\tconst size = utils.lengthBytesUTF8(str)\n\tconst ptr = this.malloc(size + 1)\n\tutils.stringToUTF8(str, this.HEAPU8, ptr, size)\n\treturn ptr\n}\n/*\n * @description: 把数组放入内存\n * @param {Array} arr: 数组\n * @param {String} type: 类型（可选）\n * @return {Number} buffer offset\n */\nWASM.prototype.arr2mem = function (arr, type = 'i32') {\n\tconst heap = this.heap(type)\n\tconst bytes = heap.BYTES_PER_ELEMENT\n\tconst ptr = this.malloc(arr.length * bytes)\n\theap.set(arr, ptr / bytes)\n\treturn ptr\n}\n/*\n * @description: 从内存读取数组\n * @param {Number} ptr: buffer offset\n * @param {Number} length: 读取长度\n * @param {String} type: 类型（可选）\n * @return {Array}\n */\nWASM.prototype.mem2arr = function (ptr, length, type = 'i32') {\n\tconst heap = this.heap(type)\n\tconst pos = ptr / heap.BYTES_PER_ELEMENT\n\treturn Array.from(heap.subarray(pos, pos + length))\n}\n/*\n * @description: 分配内存\n * @param {Number} bytes: 字节长度\n * @return {Number}\n */\nWASM.prototype.malloc = function (bytes) {\n\tconst exports = this.exports\n\tlet ptr = 0\n\tif (typeof exports.malloc === 'function') {\n\t\tptr = exports.malloc(bytes)\n\t} else {\n\t\tconst stack = exports.stackSave()\n\t\tif (bytes > stack) {\n\t\t\tthrow new Error('stack overflow')\n\t\t}\n\t\tif (this.stack === 0) {\n\t\t\tthis.stack = stack\n\t\t}\n\t\tptr = exports.stackAlloc(bytes)\n\t}\n\treturn ptr\n}\n/*\n * @description: 释放内存\n * @param {...Number} args: buffer offset\n */\nWASM.prototype.free = function (...args) {\n\tconst exports = this.exports\n\tif (typeof exports.free === 'function') {\n\t\targs.forEach((ptr) => {\n\t\t\texports.free(ptr)\n\t\t})\n\t}\n\tif (this.stack) {\n\t\texports.stackRestore(this.stack)\n\t\tthis.stack = 0\n\t}\n}\n/*\n * @description: 获取内存\n * @param {String} type: i32:HEAP32,i8:HEAP8,i16:HEAP16,u8:HEAPU8,u16:HEAPU16,u32:HEAPU32,float:HEAPF32,double:HEAPF64\n * @return {TypeArray}\n */\nWASM.prototype.heap = function (type = 'i32') {\n\tswitch (type) {\n\tcase 'i8':\n\t\treturn this.HEAP8\n\tcase 'i16':\n\t\treturn this.HEAP16\n\tcase 'u8':\n\t\treturn this.HEAPU8\n\tcase 'u16':\n\t\treturn this.HEAPU16\n\tcase 'u32':\n\t\treturn this.HEAPU32\n\tcase 'float':\n\t\treturn this.HEAPF32\n\tcase 'double':\n\t\treturn this.HEAPF64\n\tdefault:\n\t\treturn this.HEAP32\n\t}\n}\n\nlet _instance = null;\nvar wasm = null;\nlet _defaultFn = function () {}\nif (typeof importObject !== 'object') {\n  importObject = {};\n}\nif (typeof importObject.env !== 'object') {\n  importObject.env = {}\n}\nimportObject.env.emscripten_resize_heap = importObject.env.emscripten_resize_heap || _defaultFn;\nimportObject.env.emscripten_memcpy_big = importObject.env.emscripten_memcpy_big || _defaultFn;\nlet _initWASM = function (e) {\n  if (e.data.type === '".concat(o,"') {\n    WebAssembly.instantiate(e.data.mod, importObject).then(function(instance) {\n      _instance = instance;\n      wasm = new Proxy(new WASM(instance), {\n        get: (obj, k) => {\n          if (k in obj) {\n            return obj[k]\n          }\n          if (k in obj.exports) {\n            return obj.exports[k]\n          }\n        },\n        set: (obj, k, val) => {\n          const exclude = [\n            'malloc',\n            'free',\n            'exports',\n            'memory',\n            'HEAP8',\n            'HEAP16',\n            'HEAP32',\n            'HEAPU8',\n            'HEAPU16',\n            'HEAPU32',\n            'HEAPF32',\n            'HEAPF64',\n          ]\n          if (exclude.includes(k)) {\n            return false\n          }\n          obj[k] = val\n          return true\n        }\n      })\n      postMessage({\n        type: 'webassemblyready'\n      })\n    });\n    removeEventListener('message', _initWASM);\n    _initWASM = null;\n  }\n}\naddEventListener('message', _initWASM)\n");t.WASM=e,t.default=function(t){return t=new e(t,1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}),new Proxy(t,{get:function(t,n){return n in t?t[n]:n in t.exports?t.exports[n]:void 0},set:function(t,n,e){return!["malloc","free","exports","memory","HEAP8","HEAP16","HEAP32","HEAPU8","HEAPU16","HEAPU32","HEAPF32","HEAPF64"].includes(n)&&(t[n]=e,!0)}})},t.load=s,t.utils=l,t.worker=function(t,n){var e=null;(n=document.querySelector(n))&&(e=window.URL.createObjectURL(new Blob([i+n.textContent])));var r=new Worker(e);return"string"==typeof t?s(t).then(function(t){r.postMessage({type:o,mod:t})}):r.postMessage({type:o,mod:t}),r},Object.defineProperty(t,"__esModule",{value:!0})});